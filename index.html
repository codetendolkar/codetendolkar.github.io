<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Bootstrap 101 Template</title>

    <!-- Bootstrap -->
    <link href="vendor/bootstrap.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-md-7">
            <h1>Visualise t-SNE</h1>
            <div id="animationContainer"></div>
        </div>
        <div class="col-md-5">
            <div class="container-fluid">
                <form id="controlForm" style="margin-bottom: 0">
                    <div class="row">
                        <div class="col-md-6" style="padding-left: 0">
                            <div class="form-group">
                                <label for="perplexity">Enter Perplexity</label>
                                <input type="text" class="form-control" id="perplexity" aria-describedby="perplexityHelp" placeholder="Enter perplexity" value="20">
                                <small id="perplexityHelp" class="form-text text-muted">Original paper claims values 5-50 work best</small>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="perplexity">Dimension</label>
                                <input type="text" class="form-control" id="dimension" aria-describedby="dimensionHelp" placeholder="Enter dimension" value="3">
                                <small id="dimensionHelp" class="form-text text-muted">Integer greater than 1</small>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-4" style="padding-left: 0">
                            <div class="form-group">
                                <label for="perplexity">Number of Points</label>
                                <input type="text" class="form-control" id="numPoints" aria-describedby="numPointsHelp" placeholder="Enter number of points" value="10">
                                <small id="numPointsHelp" class="form-text text-muted">Values greater than 100 might make it slower</small>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="form-group">
                                <label for="numIts">Num Iterations</label>
                                <input type="text" class="form-control" id="numIts" aria-describedby="numItsHelp" placeholder="Enter number of iterations" value="1000">
                                <small id="numItsHelp" class="form-text text-muted">500 is generally sufficient</small>
                            </div>
                        </div>
                        <div class="col-md-4" style="margin-top: 25px">
                            <button type="submit" class="btn btn-primary">Run</button>
                        </div>
                    </div>
                </form>
            </div>
            <h4 style="margin-top: 0;padding-top: 0">Raw Data Projected to 2D</h4>
            <canvas id="dataCanvas"></canvas>
            <h4 style="margin-top: 0;padding-top: 0">P and Q probability matrices</h4>
            <canvas id="PMatrixCanvas"></canvas>
            <canvas id="QMatrixCanvas"></canvas>
        </div>
    </div>
</div>


<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="vendor/bootstrap.min.js"></script>
<script src="vendor/tsne.js"></script>
<script src="vendor/pixi.min.js"></script>
<script type="text/javascript">
    function generateHypersphere(dim, num_points){
        let radius = 4;
        let points = new Array(num_points);
        for (var p=0; p<num_points; p++){
            let point = new Array(dim);
            for (var d=0; d<dim; d++){
                point[d] = Math.random()-0.5;
            }
            let squaredCoords = point.map(function(coord){
                return coord*coord;
            });
            let norm = Math.sqrt(squaredCoords.reduce(function(a,b){
                    return a+b;
                })
            );
            for (var d=0; d<dim; d++){
                point[d] = point[d]*radius/norm;
            }
            points[p] = point;
        }
        return points;
    }

    function drawPMatrix(P, idx) {
        N = Math.floor(Math.sqrt(P.length));
        let min = Math.min.apply(Math, P);
        let max = Math.max.apply(Math, P);
        if (max-min===0) {
            max = 1;
            min = 0;
        }
        let canvas = document.getElementById(idx);
        let ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 200;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i < N; i++) {
            for (var j = 0; j < N; j++) {
                if (idx==="PMatrixCanvas"){
                    ctx.fillStyle = 'rgb(' + Math.floor(255*(P[i*N+j]-min)/(max-min)) + ', 0, 0)';
                } else {
                    ctx.fillStyle = 'rgb(0, ' + Math.floor(255*(P[i*N+j]-min)/(max-min)) + ', 0)';
                }

                ctx.fillRect(j * canvas.width/N, i * canvas.width/N, canvas.width/N, canvas.width/N);
                ctx.fill();
            }
        }
    }

    function autorun(Y, preplexity, num_iterations) {

        //Aliases
        let Application = PIXI.Application,
            Container = PIXI.Container,
            Graphics = PIXI.Graphics;

        //Create a Pixi Application
        let app = new Application({
                antialias: true,
                transparent: true,
                resolution: 1
            }
        );

        let canvasHeight = app.screen.height;
        let canvasWidth = app.screen.width;
        let embeddingSize = 5;

        //Add the canvas that Pixi automatically created for you to the HTML document
        var canvasContainer = document.getElementById("animationContainer");
        canvasContainer.innerHTML = '';
        canvasContainer.appendChild(app.view);

        //var Y = [[1.0, 0.1, 0.2], [0.1, 1.0, 0.3], [0.2, 0.1, 1.0]];
        var stepCount = 1;

        // Initialize points
        let embeddings;

        var initializeEmbeddings = function (Y) {
            numPoints = Y.length;
            embeddings = new Container();
            embeddings.position.set(canvasWidth/2,canvasHeight/2);
            for(var i = 0; i < numPoints; i++) {
                let circle = new Graphics();
                var hue = Math.random()*0xFFFFFF<<0;
                circle.beginFill(hue);
                circle.drawCircle(0, 0, embeddingSize);
                circle.endFill();
                embeddings.addChild(circle)
            }
            app.stage.addChild(embeddings);
        };

        var opt = {};
        opt.epsilon = 10; // epsilon is learning rate (10 = default)
        opt.perplexity = preplexity; // roughly how many neighbors each point influences (30 = default)
        opt.dim = 2; // dimensionality of the embedding (2 = default)

        var tsne = new tsnejs.tSNE(opt); // create a tSNE instance

        tsne.initDataRaw(Y);
        setup();

        let initialSolution = tsne.getSolution();
        initializeEmbeddings(initialSolution["Y"]);
        drawPMatrix(initialSolution["P"], "PMatrixCanvas");

        var renderEmbeddings = function (Y) {
            numPoints = Y.length;
            for(var i = 0; i < numPoints; i++) {
                embeddings.children[i].x = Y[i][0]*10;
                embeddings.children[i].y = Y[i][1]*10;
            }
        };

        function setup() {
            //set the game state to `play`
            state = play;

            //Start the game loop
            app.ticker.add(delta => gameLoop(delta));
        }

        function gameLoop(delta) {
            //Update the current game state:
            state(delta);
        }

        function play(delta) {
            //All the game logic goes here
            let Q = tsne.step(); // every time you call this, solution gets better
            let solution = tsne.getSolution();
            Y = solution["Y"];
            drawPMatrix(Q, "QMatrixCanvas");
            renderEmbeddings(Y);
            stepCount = stepCount+1;
            if (stepCount>num_iterations){
                state = end;
            }
        }

        function end() {
            //All the code that should run at the end of the game
            console.log("done");
            stepCount = 1;
            app.destroy();
        }
    }
    window.addEventListener("load",function() {
        document.getElementById('controlForm').addEventListener("submit",function(e) {
            e.preventDefault(); // before the code

            let dim = document.getElementById("dimension").value;
            let perp = document.getElementById("perplexity").value;
            let np = document.getElementById("numPoints").value;
            let numIts = document.getElementById("numIts").value;

            let Y = generateHypersphere(dim, np);

            let numPoints = Y.length;

            var canvas = document.getElementById("dataCanvas");
            let scale = Math.min(canvas.width, canvas.height)/10;
            var ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for(var i = 0; i < numPoints; i++) {
                ctx.fillRect(Y[i][0]*scale+canvas.width/2, Y[i][1]*scale+canvas.height/2, 2, 2);
            }
            autorun(Y, perp, numIts);
        });
    });
</script>
</body>
</html>